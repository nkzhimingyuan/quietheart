
一、ipv6地址格式(表示)
二、ipv6地址分类
三、ipv6地址配置原理简介
四、手动配置ipv6地址

一、ipv6地址格式(表示)
==========================
1.构成
IPv6地址 = 网络前缀 + 接口标识
网络前缀：相当于v4地址中的网络ID，其实还可细分为：网络前缀=全球路由前缀(网络提供商指定给组织机构，至少/48)+子网ID(组织机构内部划分，最大/64)。
接口标识：相当于v4地址中的主机ID
接口标识的生成可以是：由IEEE EUI－64规范自动生成，设备随机生成，手工配置。


2.表示
IPV6地址采用冒号分十六进制格式，即总长度128位，分8组，每组16比特，用4个16进制数表示（大小写不敏感），各组之间用"："隔开，每组中最前面的0可以省略，但每组必须得有一个数。

基本格式
FEDC:BA98:7654:3210:FEDC:BA98:7654:3210 
1080:0:0:0:8:800:200C:417A 

简化格式
在IPV6地址段中有时会出现连续的几组0，这时这些0可以用"::"代替，但一个地址中只能出现一次"::"，如下： 
1080:0:0:0:8:800:200C:417A =1080::8:800:200C:417A 
FF01:0:0:0:0:0:0:101=FF01::101 
0:0:0:0:0:0:0:1=::1 
0:0:0:AB98:123C:0:0:0=::AB98:123C:0:0:0或0:0:0:AB98:123C::。不能写成::BA98:7654::，这种写法用了多次冒号置换原则。

混合格式
某些情况下，IPV4地址需要包含在IPV6地址中，这时，最后两组用现在习惯使用的IPV4的十进制表示方法，前六组表示方法同上。如下：
0:0:0:0:0:0:61.1.133.1 或::61.1.133.1 

另外，可以用“IPv6地址/前缀长度”来表示地址前缀。这个表示方法类似于CIDR中IPv4的地址前缀表示法。这里IPv6地址是上述任一种表示法所表示的IPv6地址，前缀长度是一个十进制值，指定该地址中最左边的用于组成前缀的位数。为了说明地址前缀表示法，现举一个例，假如一个IP地址它的地址前缀为16位，IP地址为“1080::8:810:213C:123A”，则用地址前缀法表示就为：1080::8:810:213C:123A/32。


二、ipv6地址分类
==========================
    IPv6地址分为单播地址、任播地址、组播地址。和IPv4相比，取消了广播地址类型，以更丰富的组播地址代替，同时增加了任播地址类型。
    在IPv6中，任何全“0”和全“1”的字段都是合法值，除非特殊地排除在外的。特别是前缀可以包含“0”值字段或以“0”为终结。一个单接口可以指定任何类型的多个IPv6地址（单播、任意播、组播）或范围。
    在进一步介绍之前，记住以下的信息，可有助于后续的了解：
    （1）IPv6地址指定给接口，一个接口可以指定多个地址。
    （2）IPv6地址有作用域：
    a. link local地址 本链路有效
    b. site local地址 本区域（站点）内有效，一个site通常是个校园网
    c. global地址 全球有效，即可汇聚全球单播地址

1.unicast 单播（单点传送）地址
    所有非组播（格式前缀不是11111111）的，都是单播地址。发往单播地址的包被送给该地址标识的接口。对于有多个接口的节点，它的任何一个单播地址都可以用作该节点的标识符。IPv6单播地址是用连续的位掩码聚集的地址，类似于CIDR的IPv4地址。
    除保留的和未指定的IP外，IPv6中的单播地址还包括:
（1）NSAP地址：0000 001前缀。
（2）IPX分级地址：0000 010前缀。
（3）可聚集全球单播地址：001前缀，相当于ipv4公网地址。
（4）链路本地地址：格式前缀为1111 1110 10，设备自动生成，适用本地网络(不会被IPv6路由器转发),如没有路由器时主机间的通信。
（5）站点本地地址:格式前缀为1111 1110 11，类似ipv4的私网地址，被FC00::/7前缀的唯一本地地址取代。
（6）单播地址中还有下列几种特殊地址，以0000 0000为前缀：
a.不确定地址
单播地址0:0:0:0:0:0:0:0称为不确定地址。它不能分配给任何节点。它的一个应用示例是初始化主机时，在主机未取得自己的地址以前，可在它发送的任何IPv6包的源地址字段放上不确定地址。不确定地址不能在IPv6包中用作目的地址，以该地址为源地址的包也不能被路由器转发；
b.回环地址
单播地址0:0:0:0:0:0:0:1称为回环地址。节点用它来向自身发送IPv6包。它不能分配给任何物理接口，不能做源地址，不能发送给任何接口（发送了，则会被丢弃）。
c.嵌入IPV4地址的IPV6地址
::a.b.c.d,最前96比特为0，后面是ipv4地址，用于一种隧道技术（此技术已逐渐被淘汰）。
::FFFF:a.b.c.d,最前80比特为全0，中间16比特为全1，最后32比特为IPv4地址。这种地址用来把只支持IPv4的节点用IPv6地址表示。在支持双栈的IPv6节点上，IPv6应用发送目的报文是这种地址时，实际上发出的报文为IPv4报文（目的地址是“IPv4映射的IPv6地址”中的IPv4地址）。
    对于所有除了二进制000开始的单播地址（即前缀1111 1111的组播外，和格式前缀从001到111的地址）的接口标识符都必须为64比特的EUI-64格式。EUI-64格式的地址其实就是将16位的1111111111111110(0xFFFE)插入到48位MAC地址的公司ID（前24位）和扩展ID（后24位）之间。站点本地地址（前缀FEC0::/10），已停用，被唯一本地地址替代（前缀FC00::/7），详见RFC4193。


2.anycast 任播（任意点传送）地址
    一组接口（一般属于不同节点）的地址，实际属于单播地址。发往任意播地址的包只会发给该组地址接口中的一个（路由协议度量距离最近的）。IPv6任意播地址存在下列限制：
a.不能用作源地址，而只能作为目的地址；
b.不能指定给IPv6主机，只能指定给IPv6路由器；
c.从单播地址的地址空间分配，其子网前缀固定，余下位全为0。它是经过预定义的子网-路由器泛播地址，语义上无法和单播地址区分。
子网路由器器任播地址中子网前缀域用来标识特定链路。发送到子网路由器任播地址的报文会被送到子网中的一个路由器。所有路由器都必须支持子网任播地址。任播地址语义上和链路接口的接口标志符设置为0的单播地址是相同的。发给子网路由器任播地址的包文将会被发送到该子网的一台路由器，要求所有的子网路由器都支持该路由器所在端口的子网的子网路由器地址。


3.multicast 组播（多点传送）地址
    一组接口（一般属于不同节点）的地址，前缀为11111111。发往多播地址的包被送给属于该地址的所有接口。地址构成：前缀（11111111）+标志域（Flags，4位）+范围域（Scope，4位)+组ID字段（112位）。
（1）Flags字段
高3位为0保留，最后1位为1表示IANA永久分配的组播，为0表示临时的组播地址。

（2）Scope字段
确定组播范围（预定义的组播组），除未指定的外，其取值含义如下：
0 保留
1 节点本地范围
2 链路本地范围
5 站点本地范围
8 机构本地范围
E 全球
F 保留

（3）组ID字段
标识Scope给定范围内的组播组，根据Flags可能是临时的也可能是永久的。永久分配的组ID独立于范围域，临时组ID仅与某个特定范围域相关。 

目前的永久分配的“熟知”组播组除保留的外，如下：
所有节点组播地址:
FF01:0:0:0:0:0:0:1 （节点本地）
FF02:0:0:0:0:0:0:1 （链路本地）

所有路由器组播地址:
FF01:0:0:0:0:0:0:2 （节点本地）
FF02:0:0:0:0:0:0:2 （链路本地）
FF05:0:0:0:0:0:0:2 （站点本地）

被请求节点组播地址:
FF02:0:0:0:0:1:FFXX:XXXX
这里，被请求节点的地址由被请求节点的单播或任播地址形成：取被请求节点单播或任播地址的低24比特，在前面增加前缀FF02:0:0:0:0:1:FF00::/104构成被请求节点组播地址，用于替代ARP的邻居发现协议（NDP）。例如，和IPv6地址4037::01:800:200E:8C6C 对应的被请求节点组播地址是FF02::1:FF0E:8C6C。


三、ipv6地址配置原理简介
==========================
主机和路由器的ipv6地址
一个主机需要具有如下地址（哪些可选？哪些必选？）
（1）每一个接口的本链路地址（必选，不经过路由器即可和同链路网络通信，一般用于邻居发现，及无状态自动配置IP地址，路由器通告发送等场合）
（2）所有分配的单播地址（可选，可能有多个单播地址，用于与其它主机互相访问）
（3）环回地址（必选，发送只能发给自己的环回数据包）
（4）所有节点多播地址（必选，保证节点能收到其它节点发送的邻居公告或路由公告表明是否地址冲突等）
（5）与每个单播和任播地址对应的被请求节点多播地址(必选，邻居发现以及地址唯一性检测时的多播包(RS)地址)
（6）该节点所属的任何其他组的多播地址（）

除上述地址外，路由器还需要识别如下地址：
（1）每个路由器接口的子网任播地址
（2）其他的所有配置的任播地址
（3）所有路由器多播地址

一个接口可以有多个IPV6地址。多个地址分配给同一接口，使得在更换地址的过渡时期,节点能使新地址和正在淡出的旧地址（子网前缀）可以同时工作。
ipv6地址配置有手动配置和自动配置两种方式。

1.手动配置
    手工配置主机IP地址是一件非常繁琐的事情，尤其当主机IP地址需要经常改动的时候，管理分配给主机的静态IP地址是一项艰难的任务。一般用于服务器和重要的网络设备。Linux下可使用"ifconfig"、"route"或"ip"等命令对其进行配置，后面会专门讲述如何手动配置ipv6的地址。

2.自动配置
    IPv6协议支持地址自动配置，这是一种即插即用的机制，在没有任何人工干预的情况下，IPv6网络接口可以获得链路局部地址、站点局部地址和全局地址等，并且可以防止地址重复。IPv6支持“无状态地址自动配置”和“有状态地址自动配置”两种方式。无状态自动配置一般默认支持，后面会讲述如何使用dhcp v6对IP v6地址进行有状态自动配置。

（1）无状态自动配置：
　　无状态地址自动配置在具有组播能力的接口被启用时（例如刚启动系统）开始进行，此时需要配置地址的网络接口先使用邻居发现机制获得一个链路本地地址。网络接口得到这个链路本地地址之后，再发送路由器请求（RS），接受路由器响应的路由器通告以获得地址网络前缀，网络前缀结合接口标识得到一个全局单播地址。如果没有路由器，主机可以只生成链路本地地址。链路本地地址只能用于和同一链路上的节点进行通信。
具体过程如下:
    假设路由器r1，待配置的主机host1。r1已经在与host1互联的接口上配置好了一个可聚集全球单播地址。
    a.host1为自己创建链路本地地址（该操作不要求链路上有路由器，通过本地链路前缀 FE80::0 和接口标识符组合而成）。
    b.host1检验地址在链路上是否唯一，是则使用本地链路地址并且继续，否则需要人工干预（该操作不要求链路上有路由器）。
    获取到链路本地地址之后，host1就具备了在 IP 层上与邻居节点通信的能力。接下来要讲的自动配置步骤只适用于主机不适合路由器。
    下一个阶段，如果链路上有路由器，host1则根据路由器通告信息确定是应通过无状态机制，还是有状态机制实现自动配置；如果无路由器，则进行有状态自动配置。
    对无状态自动配置，继续如下过程：
    d.host1通过r1的路由器通告（RA）发现这条链路上的网络前缀（prefix）。
    e.host1生成一个接口ID（interface id），并添加在prefix的后面。
    f.host1通过重复地址检测机制（DAD）判断地址是否唯一，如果唯一则使用此地址，否则需要手动干预。
    为加速自动配置过程,主机一边产生本地链路地址(并验证它的唯一性),一边等待路由通告。地址冲突检测可通过配置接口来激活或省略。

    IPV6无状态地址配置协议是广泛采用的地址配置方式，配置该协议的主机只需相邻路由开启路由公告功能。由于有了无状态自动配置机制，一个企业更换sp的时候就不需要手动在每台pc上更换地址，而只需将路由器每个接口的prefix改掉。由于无状态地址配置中，路由器不保存ipv6主机的具体地址信息，所以可管理性差，而且也不能获取DNS服务器的地址和域名等信息，同时，对ISP服务商来说也没有指明给路由器分配的IP前缀的规范，只能手动为路由器和交换机配置ipv6地址，（路由器还可能有一个类似radvd的守护进程发送通告）。我们可以通过结合DHCP v6的无状态配置方式，来改善其缺点（见后面）。

（2）有状态自动配置(DHCP V6)：
    有状态地址自动配置的方式，与IPv4的DHCP(动态主机配置协议)一样，需要一个DHCP服务器，通过 客户机/服务器 模式从DHCP服务器处得到地址配置的信息。有状态自动配置和无状态自动配置可以一起使用。

DHCPv6典型组网中包括以下三种角色：
    DHCPv6客户端：动态获取IPv6地址、IPv6前缀或其他网络配置参数的设备。
    DHCPv6服务器：负责为DHCPv6客户端分配IPv6地址、IPv6前缀和其他网络配置参数的设备。需要注意的是：分配IPv6前缀后，DHCPv6客户端（一般是路由器）便能向所在网络发送包含该前缀信息的RA消息，以便网络内的主机根据该前缀自动配置IPv6地址。
    DHCPv6中继：DHCPv6客户端通过本地链路范围的组播地址与DHCPv6服务器通信，以获取IPv6地址和其他网络配置参数。如果服务器和客户端不在同一个链路范围内，则需要通过DHCPv6中继来转发报文，这样可以避免在每个链路范围内都部署DHCPv6服务器，既节省了成本，又便于进行集中管理。

（2.1）DHCPv6地址/前缀分配过程
    DHCPv6服务器为客户端分配地址/前缀的过程分为两类：交互四个消息的分配过程，和交互两个消息的快速分配过程。

    交互四个消息的分配过程：
    a.Solicit，DHCPv6客户端发送该消息，请求DHCPv6服务器为其分配IPv6地址/前缀和网络配置参数。
    b.Advertise，如果Solicit消息中无Rapid Commit选项，或有Rapid Commit选项，但服务器不支持快速分配过程，则DHCPv6服务器回复该消息，通知客户端可以为其分配的地址/前缀和网络配置参数。
    c.Request，如果DHCPv6客户端接收到多个服务器回复的Advertise消息，则根据消息接收的先后顺序、服务器优先级等，选择其中一台服务器，并向该服务器发送Request消息，请求服务器确认为其分配地址/前缀和网络配置参数。
    d.Reply，DHCPv6服务器回复该消息，确认将地址/前缀和网络配置参数分配给客户端使用。

    交互两个消息的快速分配过程:
    a.DHCPv6客户端在发送的Solicit消息中携带Rapid Commit选项，标识客户端希望服务器能够快速为其分配地址/前缀和网络配置参数；
    b.如果DHCPv6服务器支持快速分配过程，则直接返回Reply消息，为客户端分配IPv6地址/前缀和其他网络配置参数。如果DHCPv6服务器不支持快速分配过程，则采用交互四个消息的分配过程为客户端分配IPv6地址/前缀和其他网络配置参数。

（2.2）地址/前缀租约更新过程
    DHCPv6服务器分配给客户端的IPv6地址/前缀具有一定的租借期限。租借期限由有效生命期（Valid Lifetime）决定。地址/前缀的租借时间到达有效生命期后，DHCPv6客户端不能再使用该地址/前缀。在有效生命期到达之前，如果DHCPv6客户端希望继续使用该地址/前缀，则需要更新地址/前缀租约。
    具体如下：
    a.地址/前缀租借时间到达时间T1（推荐值为首选生命期Preferred Lifetime的一半）时，DHCPv6客户端会向为它分配地址/前缀的DHCPv6服务器单播发送Renew报文，以进行地址/前缀租约的更新。
    b.如果客户端可以继续使用该地址/前缀，则DHCPv6服务器回应续约成功的Reply报文，通知DHCPv6客户端已经成功更新地址/前缀租约；如果该地址/前缀不可以再分配给该客户端，则DHCPv6服务器回应续约失败的Reply报文，通知客户端不能获得新的租约。
    c.如果在T1时发送Renew请求更新租约，但是没有收到DHCPv6服务器的回应报文，则DHCPv6客户端会在T2（推荐值为首选生命期的0.8倍）时，向所有DHCPv6服务器组播发送Rebind报文请求更新租约。
    d.如果客户端可以继续使用该地址/前缀，则DHCPv6服务器回应续约成功的Reply报文，通知DHCPv6客户端已经成功更新地址/前缀租约；如果该地址/前缀不可以再分配给该客户端，则DHCPv6服务器回应续约失败的Reply报文，通知客户端不能获得新的租约。
    e.如果到达有效生命期后，DHCPv6客户端仍没有收到服务器的应答报文，客户端停止使用该地址/前缀。

（2.3）DHCPv6中继工作过程
    通过DHCPv6中继动态获取IPv6地址/前缀和其他网络配置参数的过程中，DHCPv6客户端与DHCPv6服务器的处理方式与不通过DHCPv6中继时的处理方式基本相同。
    具体如下：
    a.DHCPv6客户端向所有DHCPv6服务器和中继的组播地址FF02::1:2发送请求；
    b.DHCPv6中继接收到请求后，将其封装在Relay-forward报文的中继消息选项（Relay Message Option）中，并送给DHCPv6服务器；
    c.DHCPv6服务器从Relay-forward报文中解析出客户端的请求，为客户端选取IPv6地址和其他参数，构造应答消息，将应答消息封装在Relay-reply报文的中继消息选项中，并发送给DHCPv6中继；
    c.DHCPv6中继从Relay-reply报文中解析出服务器的应答，转发给DHCPv6客户端；
    e.DHCPv6客户端根据DHCPv6服务器分配的IPv6地址/前缀和其他参数进行网络配置。

    在有状态的dhcpv6地址自动配置中，最终的服务器能把ipv6地址和客户关系记录在案，方便了管理；并且，除了给主机提供一个完整的ipv6地址外，还可以对主机的DNS服务器的地址和域名等其它信息进行自动配置；另外DHCP v6还提供了前缀代理扩展功能，可以自动为下游路由器分配网络前缀，减少了手动部署网络的困难。

（2.4）DHCPv6无状态配置过程
    DHCP V6还提供了无状态DHCP V6服务，即只对DNS服务器的地址和域名等其它信息进行自动配置，而不分配IPV6地址，IP v6地址仍由路由通告方式获取。DHCPv6客户端通过地址无状态自动配置功能成功获取IPv6地址后，如果接收到的RA（Router Advertisement，路由器通告）报文中M标志位（被管理地址配置标志位）为0、O标志位（其他配置标志位）为1，则DHCPv6客户端会自动启动DHCPv6无状态配置功能，以获取除地址/前缀外的其他网络配置参数（M 标记设置为1时，此标记指示主机使用配置协议来获取有状态地址）。
    获取地址/前缀之外的其他网络参数过程具体如下：
    a.客户端以组播的方式向DHCPv6服务器发送Information-request报文，该报文中携带Option Request选项，指定客户端需要从服务器获取的配置参数。
    b.服务器收到Information-request报文后，为客户端分配网络配置参数，并单播发送Reply报文将网络配置参数返回给客户端。
    c.客户端检查Reply报文中提供的信息，如果与Information-request报文中请求的配置参数相符，则按照Reply报文中提供的参数进行网络配置；否则，忽略该参数。如果接收到多个Reply报文，客户端将选择最先收到的Reply报文，并根据该报文中提供的参数完成客户端无状态配.



四、手动配置ipv6地址
==========================
    默认启动ipv6之后，会采用无状态自动配置方式生成一个ipv6地址。若没有支持IPV6的路由和DHCP服务器，则网口只有一个本地链路地址（仅能与在本子网链路中的IPV6主机通信），此时我们可以手动配置主机的ipv6地址（如站点本地地址或全球单播地址等）。如果我们没有向ISP申请全球单播IP，那我们只能设置站点本地地址（即用于局域网的地址）。这里只给出ipv6配置的基本命令，具体配置过程需要根据实际情况而定：
1.查看ipv6地址
#ifconfig
或#ip -6 addr show dev eth0

2.查看ipv6路由
#route -A inet6
或#ip -6 route show dev eth0
或#ip -6 route list table main dev eth0
这里，dev部分可以忽略。


3.添加一个ipv6地址
#ifconfig eth0 inet6 add fe80::f2de:f1ff:fef0:861/64
或#ip -6 addr add fe80::f2de:f1ff:fef0:861/64 dev eth0
这会在已有的ipv6地址上，增加一个fe80::f2de:f1ff:fef0:860/64。

4.删除一个ipv6地址
#ifconfig eth0 inet6 del fe80::f2de:f1ff:fef0:860/64
或#ip -6 addr del fe80::f2de:f1ff:fef0:861/64 dev eth0

5.ipv6路由配置
（1）经由网关连至外面
语法：
# /sbin/route –A inet6 add <ipv6network>/<prefixlength> gw <ipv6address> [dev <device>]
或 # /sbin/ip -6 route <ipv6network>/<prefixlength> via <ipv6address> [dev <device>]

例子：添加2000::/3的路由（即一个表项），经过网关3ffe::ffff:0:f101::1
# /sbin/route –A inet6 add 2000::/3 gw 3ffe:ffff:0:f101::1
# /sbin/ip -6 route 2000::/3 via 3ffe:ffff:0:f101::1

（2）向指定接口发送
语法：
#/sbin/route –A inet6 add <network>/<prefixlength> dev <device>

例子：添加2000::/3的路由（即一个表项），发送至eth0
#/sbin/route –A inet6 add 2000::/3 dev eth0

（3）设定网关（未实践）
若要让linux成为网关，则：
# echo 1 > /proc/sys/net/ipv6/conf/all/forwarding
或使用radvd daemon（Router ADVertisement Daemon），支持路由的自动设定（无状态配置）：
/usr/local/sbin/radvd


http://blog.sina.com.cn/s/blog_635e1a9e01018ys1.html
http://www.ipv6.org.tw/NDHU/article/20020718.htm
http://blog.csdn.net/xuleilx/article/details/7480580
http://zhidao.baidu.com/link?url=SAC2R5HeL5ux9BoJZcmKwtqyKc3t6MCD5X91xSfBttJvNAqq4c29lq52E-aH2y0cDsXBA39MUYzLVNpyZsmTeK

参考：
*http://www.h3c.com.cn/Solution/Base_Network_Secrity/IPv6_Solutions/What_Do_I_Need/Bookmark/200711/319403_30004_0.htm
http://www.360doc.com/content/12/0313/13/3725126_193980948.shtml
http://ipv6.tsinghua.edu.cn/technology/ipv6-di-zhi-jie-shao/
http://tech.ccidnet.com/art/3723/20070923/1221843_1.html
http://wenku.baidu.com/view/a533ac0ef12d2af90242e6cb.html
http://wenku.baidu.com/view/a63145f9aef8941ea76e0532.html
http://wenku.baidu.com/view/56e7b6728e9951e79b89279d.html
http://wenku.baidu.com/view/a35ad41810a6f524ccbf85b4.html
http://wenku.baidu.com/view/c72fdd4733687e21af45a965.html
http://baike.baidu.com/link?url=LFZYYIpsqzpQBmXUDvzS7uZGuDfj30RKnFaEeyHvEfDl-tIZuUrn7WWdRNMwTxGMbv-bJmToe6S3No1RkWSoFa
*blog.chinaunix.net/uid-13746440-id-3614921.html
http://blog.csdn.net/l_serein/article/details/6115999
*http://blog.csdn.net/xuleilx/article/details/7480580
http://docs.oracle.com/cd/E24847_01/html/819-7058/chapter1-42.html
http://www.2cto.com/net/201305/210563.html
*http://www.ietf.org/rfc/rfc2462




===========待整理


实际的设置例子：
1，pc信息：
（1）设置前信息
#ifconfig eth0
eth0      Link encap:以太网  硬件地址 f0:de:f1:f0:08:60
          inet 地址:192.168.0.112  广播:192.168.0.255  掩码:255.255.255.0
          inet6 地址: fe80::f2de:f1ff:fef0:860/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  跃点数:1
          接收数据包:245747 错误:0 丢弃:0 过载:0 帧数:0
          发送数据包:198234 错误:0 丢弃:0 过载:0 载波:0
          碰撞:0 发送队列长度:1000
          接收字节:177545392 (177.5 MB)  发送字节:45963948 (45.9 MB)
          中断:40 基本地址:0x6000

# ip -6 rule list
0:      from all lookup local 
32766:  from all lookup main 

#ip -6 route list table local
local ::1 via :: dev lo  proto none  metric 0 
local fe80::f2de:f1ff:fef0:860 via :: dev lo  proto none  metric 0 
ff00::/8 dev eth0  metric 256

#ip -6 route list table main
fe80::/64 dev eth0  proto kernel  metric 256

# route -A inet6
内核 IPv6 路由表
Destination                    Next Hop                   Flag Met Ref Use If
fe80::/64                      ::                         U    256 0     0 eth0
::/0                           ::                         !n   -1  1 13343 lo
::1/128                        ::                         Un   0   1    20 lo
fe80::f2de:f1ff:fef0:860/128   ::                         Un   0   1     0 lo
ff00::/8                       ::                         U    256 0     0 eth0
::/0                           ::                         !n   -1  1 13343 lo


（2）设置
站点本地地址：
#ip -6 addr add fec0::f2de:f1ff:fef0:0860/64 dev eth0
注意，这里最后64比特按照EUI-64规范设置。


（3）设置后信息：
#ifconfig eth0
eth0      Link encap:以太网  硬件地址 f0:de:f1:f0:08:60  
          inet 地址:192.168.0.112  广播:192.168.0.255  掩码:255.255.255.0
          inet6 地址: fec0::f2de:f1ff:fef0:860/64 Scope:Site
          inet6 地址: fe80::f2de:f1ff:fef0:860/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  跃点数:1
          接收数据包:245933 错误:0 丢弃:0 过载:0 帧数:0
          发送数据包:198621 错误:0 丢弃:0 过载:0 载波:0
          碰撞:0 发送队列长度:1000 
          接收字节:177556552 (177.5 MB)  发送字节:45986645 (45.9 MB)
          中断:40 基本地址:0x6000

# ip -6 rule list
0:      from all lookup local 
32766:  from all lookup main 

# ip -6 route list table local
local ::1 via :: dev lo  proto none  metric 0 
local fe80::f2de:f1ff:fef0:860 via :: dev lo  proto none  metric 0 
local fec0::f2de:f1ff:fef0:860 via :: dev lo  proto none  metric 0 
ff00::/8 dev eth0  metric 256 

# ip -6 route list table main
fe80::/64 dev eth0  proto kernel  metric 256 
fec0::/64 dev eth0  proto kernel  metric 256

# route -A inet6
内核 IPv6 路由表
Destination                    Next Hop                   Flag Met Ref Use If
fe80::/64                      ::                         U    256 0     0 eth0
fec0::/64                      ::                         U    256 0     0 eth0
::/0                           ::                         !n   -1  1 14219 lo
::1/128                        ::                         Un   0   1    20 lo
fe80::f2de:f1ff:fef0:860/128   ::                         Un   0   1     0 lo
fec0::f2de:f1ff:fef0:860/128   ::                         Un   0   1     0 lo
ff00::/8                       ::                         U    256 0     0 eth0
::/0                           ::                         !n   -1  1 14219 lo


2，开发板信息
（1）设置前信息
#ifconfig eth0
eth0      Link encap:Ethernet  HWaddr 74:37:2F:22:88:88  
          inet addr:192.168.0.120  Bcast:0.0.0.0  Mask:255.255.255.255
          UP BROADCAST RUNNING MULTICAST  MTU:1492  Metric:1
          RX packets:767 errors:0 dropped:0 overruns:0 frame:0
          TX packets:607 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000 
          RX bytes:71555 (69.8 KiB)  TX bytes:194749 (190.1 KiB)
          Interrupt:52 Base address:0x7000

# ip -6 rule list
0:      from all lookup local 
32766:  from all lookup main 

# ip -6 route list table local
local ::1 via :: dev lo  metric 0

# ip -6 route list table main
unreachable default dev lo  metric -1  error -101
unreachable default dev lo  metric -1  error -101

# route -A inet6
Kernel IPv6 routing table
Destination                                 Next Hop                                Flags Metric Ref    Use Iface
::1/128                                     ::                                      U     0      0        1 lo    

（2）设置
链路本地地址：
#ip -6 addr add fe80::7437:2fff:fe22:8888/64 dev eth0
注意，这里最后64比特按照EUI-64规范设置。

站点本地地址：
#ip -6 addr add fec0::7437:2fff:fe22:8888/64 dev eth0
注意，这里最后64比特按照EUI-64规范设置。

路由：

（3）设置后信息：
# ifconfig eth0
eth0      Link encap:Ethernet  HWaddr 74:37:2F:22:88:88  
          inet addr:192.168.0.120  Bcast:0.0.0.0  Mask:255.255.255.255
          inet6 addr: fec0::7437:2fff:fe22:8888/64 Scope:Site
          inet6 addr: fe80::7437:2fff:fe22:8888/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1492  Metric:1
          RX packets:1289 errors:0 dropped:0 overruns:0 frame:0
          TX packets:1127 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000 
          RX bytes:104186 (101.7 KiB)  TX bytes:306929 (299.7 KiB)
          Interrupt:52 Base address:0x7000 

# ip -6 rule list
0:      from all lookup local 
32766:  from all lookup main

# ip -6 route list table local
local ::1 via :: dev lo  metric 0 
local fe80::7437:2fff:fe22:8888 via :: dev lo  metric 0 
local fec0::7437:2fff:fe22:8888 via :: dev lo  metric 0 

# ip -6 route list table main
fe80::/64 dev eth0  metric 256 
fec0::/64 dev eth0  metric 256 
unreachable default dev lo  metric -1  error -101
ff00::/8 dev eth0  metric 256 
unreachable default dev lo  metric -1  error -101

# route -A inet6
Kernel IPv6 routing table
Destination                                 Next Hop                                Flags Metric Ref    Use Iface
fe80::/64                                   ::                                      U     256    0        0 eth0    
fec0::/64                                   ::                                      U     256    0        0 eth0    
::1/128                                     ::                                      U     0      0        1 lo      
fe80::7437:2fff:fe22:8888/128               ::                                      U     0      0        1 lo      
fec0::7437:2fff:fe22:8888/128               ::                                      U     0      0        1 lo      
ff00::/8                                    ::                                      U     256    0        0 eth0 

3，测试状况：
PC与开发板是直连的状况。
（1）PC上
PC->开发板：
# ping6 fe80::7437:2fff:fe22:8888
connect: Invalid argument
# ping6 -I eth0 fe80::7637:2fff:fe22:8888
PING fe80::7637:2fff:fe22:8888(fe80::7637:2fff:fe22:8888) from fe80::f2de:f1ff:fef0:860 eth0: 56 data bytes
64 bytes from fe80::7637:2fff:fe22:8888: icmp_seq=1 ttl=64 time=1.33 ms
64 bytes from fe80::7637:2fff:fe22:8888: icmp_seq=2 ttl=64 time=0.479 ms
^C
# ping6 fec0::7437:2fff:fe22:8888
PING fec0::7437:2fff:fe22:8888(fec0::7437:2fff:fe22:8888) 56 data bytes
64 bytes from fec0::7437:2fff:fe22:8888: icmp_seq=1 ttl=64 time=0.930 ms
64 bytes from fec0::7437:2fff:fe22:8888: icmp_seq=2 ttl=64 time=0.453 ms
^C
可见，PC上可用ping6确定与开发板的站点本地地址互通，与链路本地地址互通，需要指定接口名(由于Link-Local地址的形式都是： FE80::a:b:c:d 格式，不带任何子网信息等指示路由。因此如果有多个网卡的机器上就有多个Link-Local地址，就必须指定从哪个接口出去，否则系统不知道是哪条链路上的地址)。

PC->PC自身：
# ping6 ::1
PING ::1(::1) 56 data bytes
64 bytes from ::1: icmp_seq=1 ttl=64 time=0.040 ms
64 bytes from ::1: icmp_seq=2 ttl=64 time=0.070 ms
^C

# ping6 fec0::f2de:f1ff:fef0:860
PING fec0::f2de:f1ff:fef0:860(fec0::f2de:f1ff:fef0:860) 56 data bytes
64 bytes from fec0::f2de:f1ff:fef0:860: icmp_seq=1 ttl=64 time=0.045 ms
64 bytes from fec0::f2de:f1ff:fef0:860: icmp_seq=2 ttl=64 time=0.058 ms
^C

# ping6 fe80::f2de:f1ff:fef0:860
connect: Invalid argument
ping6 -I eth0 fe80::f2de:f1ff:fef0:860
PING fe80::f2de:f1ff:fef0:860(fe80::f2de:f1ff:fef0:860) from fe80::f2de:f1ff:fef0:860 eth0: 56 data bytes
64 bytes from fe80::f2de:f1ff:fef0:860: icmp_seq=1 ttl=64 time=0.026 ms
64 bytes from fe80::f2de:f1ff:fef0:860: icmp_seq=2 ttl=64 time=0.082 ms
^C
可见，PC上可用ping6确定与自身的回环地址与开发板的站点本地地址互通，与链路本地地址互通需要用-I指定接口名。

PC->开发板访问：
如何用浏览器访问？
直接在地址栏中，输入英文中括号括起来的ipv6地址即可。如：[fec0::7437:2fff:fe22:8888]


（2）开发板上
开发板->PC：
# ping6[ 2577.970000] Alignment trap: ping6 (5017) PC=0x00033b60 Instr=0xe59c3004 Address=0xbeebea52 FSR 0x001
 fe80::f2de:f1ff:fef0:860
PING fe80::f2de:f1ff:fef0:860 (fe80::f2de:f1ff:fef0:860): 56 data bytes
Bus error

# ping6 fec[ 2611.360000] Alignment trap: ping6 (5067) PC=0x00033b60 Instr=0xe59c3004 Address=0xbeca3a52 FSR 0x001
0::f2de:f1ff:fef0:860
PING fec0::f2de:f1ff:fef0:860 (fec0::f2de:f1ff:fef0:860): 56 data bytes
Bus error
可见，开发板的ping6对PC无论是站点本地还是链路本地地址，均不能互通。

开发板->开发板自身：
# ping6 ::1[ 2899.510000] Alignment trap: ping6 (5515) PC=0x00033b60 Instr=0xe59c3004 Address=0xbe9fba62 FSR 0x001

PING ::1 (::1): 56 data bytes
Bus error
# ping6 fec0::7437:2fff:fe22:8888[ 2914.820000] Alignment trap: ping6 (5541) PC=0x00033b60 Instr=0xe59c3004 Address=0xbe873a52 FSR 0x001

PING fec0::7437:2fff:fe22:8888 (fec0::7437:2fff:fe22:8888): 56 data bytes
Bus error
# ping6 fe80::7437:2fff:fe22:8888[ 2924.710000] Alignment trap: ping6 (5554) PC=0x00033b60 Instr=0xe59c3004 Address=0xbed47a52 FSR 0x001

PING fe80::7437:2fff:fe22:8888 (fe80::7437:2fff:fe22:8888): 56 data bytes
Bus error

可见，开发板的ping6对自身无论是回环地址还是站点本地还是链路本地地址，均不能互通（和内核是否支持ipv6有关？）。

http://blog.csdn.net/hansel/article/details/5304103

问题：
local路由表的作用？
各种ipv6地址的使用范围？
本地链路地址如何配置？

貌似
内核支持ipv6后不够，busybox也要支持ipv6。

可能需要的
支持ipv6的设备：
路由器
服务器
交换机

支持ipv6的网络服务：
HTTP（Apache 2.x 或 Orion）
DNS

支持 IPv6的服务器
因为服务器被视为 IPv6 主机，所以，在缺省情况下，服务器的 IPv6 地址会由相邻节点搜索协议自动配置。但是，许多服务器会有多个网络接口卡 (network interface card, NIC)，您可能希望将它们换出以进行维修或更换。更换 NIC 后，相邻节点搜索会自动为新 NIC 生成一个新的接口 ID。对于特定的服务器，可能不支持此行为。
因此，请考虑为服务器的每个接口手动配置 IPv6 地址的接口 ID 部分。有关说明，请参阅如何配置用户指定的 IPv6 标记。以后需要更换现有的 NIC 时，已经配置的 IPv6 地址可应用于更换后的 NIC。

与其他ipv6站点互通
可能需要配置隧道以便能和其他站点互通

获取地址前缀
在配置 IPv6 之前，必须获取站点前缀。站点前缀用于生成IPv6实现中所有节点的 IPv6 地址。支持 IPv6 的任何 ISP 都可以提供 48 位 IPv6 站点前缀。如果当前的 ISP 仅支持 IPv4，则可能需要使用另一个 ISP 来支持 IPv6，同时保留当前的 ISP 来支持 IPv4。或者寻求其它方案。

http://docs.oracle.com/cd/E24847_01/html/819-7058/ipv6-planning-7.html#scrolltoc


其它
==========================

IPV6地址分配：
全球单播地址空间
ICANN从整个可聚合全球单播地址空间（格式前缀为001）中取2001::/16进行分配给各大洲地区级的Internet注册机构（Regional Internet Registry，RIR），RIR再从得到的地址空间分配/32前缀给IPv6 ISP，IPv6 ISP再从/32前缀中分配/48前缀给每个客户。/48前缀的地址空间还可以进一步分为/64前缀的子网。这样每个客户最大可以有65535个子网。为了限制IPv4地址分配初期的不合理分配方案，每个ISP必须同时满足下列条件才能获得/32前缀：
Ø         部署外部路由协议
Ø         至少与3个ISP相连
Ø         至少有40个客户或至少在12个月内显示有意提供IPv6服务

IPv6实验网络地址分配（6BONE）
6BONE网络是全球范围的IPv6实验网络，使用网络前缀3ffe:0000::/16。每个伪顶级聚合分配3ffe:0800::/28范围内的/28前缀，最多支持2048个伪顶级聚合。处于末端的站点再从上游提供者得到/48前缀，每个站点内还可细分为多个/64前缀。
6BONE网络按层次化结构分配地址，地址空间由IANA定义配，分配策略在RFC2921（6BONE伪顶级聚合和网络层聚合格式）中定义。
注：6BONE的地址空间3FFE::/16已经于2006年6月6日停用。所有使用6bone前缀的网络必须过渡到使用由RIR分配的商用IPv6地址空间。


IPv6基本功能
==============
IPv6基本功能包括IPv6邻居发现协议、IPv6路径MTU发现以及IPv6域名解析。重点介绍邻居发现。

邻居发现：
    邻居发现协议（Neighbor Discovery Protocol简写为ND），是IPv6协议的一个基本的组成部分，在IPV4中则需要许多协议，包括DHCP,ICMP路由器发现，路由协议和ARP等才能提供上述功能的一部分。ND使用ICMPV6来实现上述功能，ND试图通过将所有功能集成到IPV6的必要部分ICMPV6中来改进IPV4。
    该协议使用消息传递作为处理相邻节点间的交互的方式。相邻节点是指在同一链路上的 IPv6 节点。例如，通过发出与相邻节点搜索相关的消息，节点可以获知相邻节点的链路本地地址。邻节点搜索控制 IPv6 本地链路上的以下主要活动：
    路由器搜索－帮助主机查找本地链路上的路由器。
    地址自动配置－使节点能够为其接口自动配置 IPv6 地址。
    前缀搜索－使节点能够搜索已分配给链路的已知子网前缀。节点使用前缀来区分位于本地链路上的目标和那些只能通过路由器来访问的目标。
    地址解析－帮助节点确定相邻节点的链路本地地址（如果只给定目标的 IP 地址）。
    确定下一个跃点－使用某种算法来确定本地链路之外的包接受者的跃点的 IP 地址。下一个跃点可以是路由器或目标节点。
    相邻节点无法访问检测－帮助节点确定相邻节点是否不再可以访问。对于路由器和主机，可以重复进行地址解析。
    重复地址检测－使节点能够确定其要使用的地址是否尚未被使用。
    重定向－使路由器能够通知主机要用于到达特定目标的较好的第一个跃点节点。

1.数据包类型
    邻居发现协议实现了路由器和前缀发现、地址解析、下一跳地址确定、重定向、邻居不可达检测、重复地址检测等功能。 邻居发现协议的上述功能通过5种类型的IPv6控制信息报文（ICMPv6）来实现：

（1）路由器请求（Router Solicitation）
    路由请求(RS)为ICMP报文，类型为133。
    IPV6 Source Address：发送主机链路本地地址(IP地址)，或::0（若主机没有被分配的地址）。
    IPV6 Destination Address：所有路由器组播地址（FF02::2）。
    功能：
    当主机没有配置单播地址（例如系统刚启动）时，就会发送路由器请求报文（如果不是::0，可在ICMP中带上自己的源链路层地址）。发送路由器请求报文后，主机迅速进行自动配置而不必等待路由器的周期性IPv6路由器通告报文。

（2）路由器通告（Router Advertisement）
    路由通告(RA)为ICMP报文，类型为134。
    IPV6 Source Address：发送者（路由器)的链路本地地址。
    IPV6 Destination Address：发送路由器请求的节点地址（回复RS），或所有节点的链路本地组播地址（FF02 ::1）（周期性公告）。
    功能：
    每个IPv6路由器的配置接口会周期发送路由器通告报文到所有节点的链路本地组播地址（FF02 ::1）。在本地链路上收到IPv6节点的路由器请求报文后，路由器也会迅速发送（回复）路由器通告报文给发送路由器请求报文节点的IPv6单播地址（顺便在有链路层有地址时也发送自己的接口链路层地址，这样可省去对默认路由的地址解析）。
    本地链路上的IPv6节点接收到路由器通告报文，会用其中的信息得到更新的缺省路由器、前缀列表以及其它配置。

（3）邻居请求（Neighbor Solicitation）
    邻居请求(NS)为ICMP报文，类型为135。
    IPV6 Source Address：发送主机被指定的接口IP地址，或::0（重复地址检测时）。
    IPV6 Destination Address：被请求节点多播地址（FF02:0:0:0:0:1:FFXX:XXXX）（用于地址解析），或目标主机IP地址。
    ICMPV6 Target Address：被请求节点（即目标主机）的IP地址（也就是待解析的单播IP地址）。
    功能：
    当需要地址解析（即一个节点需要得到同一本地链路上另外一个节点的链路层地址，如MAC地址）时，就会发送邻居请求报文（同时，若自己IP不是未指定的::0时也提供自己的链路层地址给目标节点）。此报文类似于IPv4中的ARP请求报文，不过使用被请求节点组播地址而不使用广播，只有被请求节点的最后24比特和此组播相同的节点才会收到此报文，减少了广播风暴的可能。
    邻居请求报文也用来在邻居的链路层地址已知时验证邻居的可达性，以及重复地址的检测，此时使用单播IP地址。

（4）邻居通告（Neighbor Advertisement）
    邻居通告(NA)为ICMP报文，类型为136。
    IPV6 Source Address：发送此包主机被指定的接口IP地址。
    IPV6 Destination Address：NS发送者IP地址(响应NS)，或所有节点多播地址（主动通告链路层的改变，或NS发送者IP为::0未指定）。
    ICMPV6 Target Address：NS中的ICMPV6 Target Address，即被请求者IP地址（回应NS），或链路层被改变的接口地址（主动通告）。
    功能：
    节点发送NS以响应NS，发送非请求NA（即主动通告）以快速传播节点变化的新信息。收到邻居请求报文后，节点会给发送者回复邻居通告报文。收到邻居通告后，源节点和目的节点可以进行通信。当一个节点的本地链路上的链路层地址改变时也会主动发送邻居通告报文，此时使用的目的地址是所有节点多播地址。

（5）重定向（Redirect）
    重定向消息为ICMP报文，类型为137。
    IPV6源地址：发送此包主机的本地链路地址。
    IPV6目标地址：引起重定向的分组的IPV6源地址。
    ICMPV6 Target Address：针对ICMPV6 Destination Address较好第一跳路由本地链路地址（是IP地址），ICMPV6 Destination Address（目的是邻居）。
    ICMPV6 Destination Address：重定向到目标的目的地的IP地址。
    功能：
    路由器通过重定向消息通知主机。对于特定的目的地址，如果不是最佳的路由，则通知主机到达目的地的最佳下一跳。收到重定向报文的节点随后会把后续报文发送到更合适的路由器。路由器只针对单播流发送重定向报文，重定向报文只发给引起重定向的报文的发起节点（主机），并被处理。


2.主机维护的接口信息
无论实现方式如何，主机应当需要维护如下的信息。
Neighbor Cache
包含最近有流量（交互）邻居信息。每个条目包含：邻居的链路层地址、邻居是主机还是路由的标记、等待地址解析完成的排队分组指示符等，还包含邻居不可达检测所需的信息如：可达状态、未回答探测数目、下一次不可达事件发生时间。

Destination Cache
关于最近有流量（交互）的目的地址信息。这些目的地址可能是on-link(在同一链路无需路由的)，也可能off-link(不在同链路)。它们映射了到下一跳邻居的IP地址的目的地IP地址（目的IP：邻居IP），由此可进入Neighbor Cache进行查询。此缓存由Redirect中的信息学习更新，它们也可方便地存入一些不直接与Neighbor相关的信息，如Path MTU和有传输协议维护的往返定时器。

Prefix List
定义了一组on-link地址的前缀列表，其内容由收到的RA生成。每个条目有一个相关的失效定时器用于当前缀无效时，不使用该条目（前缀）。计时器内容可由RA来更新。另外注意的是本地链路地址的前缀也在这个列表上，且失效计时器为无限（即不会失效），收到的RA也不会更新它。

Default Router List
包含路由器的列表，分组可能会发送到这些路由器上。其条目指向Neighbor Cache中的条目，也有一个可由RA更新的失效定时器。选择缺省路由器的算法，会优先选择那些比起其它路由器更可能会可达的路由器。


3.主机的行为
    当向一个目的地发送报文时，节点使用Destination Cache，Prefix List和Default Router List来共同决定合适的下一跳的IP地址，该操作称为下一跳决定（next-hop determination）。一旦知道了下一跳的IP地址，则在Neighbor Cache查询该邻居的链路层信息。
    （1）下一跳IP地址的决定：Prefix List+Default Router List
    对于给定单播地址的下一跳决定的操作如下：发送者对照Prefix List进行最长匹配来确定报文的目的地是on-link还是off-link。如果是on-link，则报文的下一跳地址与目的地址一样。否则，发送者从Default Router List中选出一个路由器。如果Default Router List为空，则发送者假定目的地是on-link。
    （2）缓存下一条IP地址：Destination Cache
    考虑到效率，不是每一个发送报文都进行下一跳判定。下一跳判定的结果存储在Destination Cache（也包含了来自重定向消息学习的更新）。发送报文时，发送者首先检查Destination Cache，如果目的地的表项不存在，则进行下一跳决策来创建一个目的地表项。
    （3）获取下一跳IP地址对应的邻居链路层地址：Neighbor Cache
    一旦知道了下一跳节点的IP地址，发送者就在Neighbor Cache查找那个邻居的链路层信息。如果表项不存在，发送者会创建一个，将它的状态置为INCOMPLETE，发起地址解析，并将等待地址解析完成的报文入队列。对于与组播能力的接口来说，地址解析包含了发送邻居请求消息和等待邻居通告。当收到邻居通告响应，链路层地址被填入邻居缓存项并且发送排队的报文。
    另外，对于组播报文，下一跳总是（组播）目的地址并且被认为是on-link。确定对应一个IP组播地址的链路层地址与链路层相关。

    每当发生发送单播分组时访问一次Neighbor Cache条目，发送者便根据邻居不可达检测算法检测一次，此不可达检测通过发送单播的NS来验证邻居是否可达。
    当数据首次发送到目的地时，进行下一跳的确定（同时将Destination Cache更新）。只要那个目的地的后续通信能成功进行，就继续使用Destinaton Cache中的内容。如果邻居不可达算法检测到通信在某一处停止了，就可能会重新需要确认下一跳地址。需要注意的是，当节点重做下一跳决定时，不需要完全抛弃相应的Destinaton Cache条目，如PMTU和环回计时器值通常是有用的，会被保留下来。


4.清理无用信息
对于不同的无用信息，用不同的机制来清理。
对于Destinaton Cache和Neighbor Cache的无用条目，我们可以不清除，但是若想周期清除其中的无用条目，可在邻居不可达检测算法中加入相应功能。
为避免条目重复删除和建立导致链路中邻居发现消息过量，可使用最近最少使用策略（LRU）或仅收回一段时间内没有使用的条目。

对于每个节点对应的Default Router List和Prefix List的条目，在其生存期间应当一直保留；然而如果存储空间不够时，节点可以收集未到期的条目。如果不是所有路由器都在Default Router List中，那Default Router List至少应该有两个条目，以便维护off-link链接的稳定。
当从Prefix List中删除条目时，不需要从Destinaton Cache或Neighbor Cache中清楚任何条目，邻居不可达算法会对其中的失效条目清理。
当从Default Router删除条目时，Destinaton Cache中搜索的相应路由器的任何条目必须再次执行一次下一跳确定，以便重新选择一个新的默认路由。

5.地址解析

???6.重复地址检测(DAD)
重复地址检测（Duplicate Address Detection，简写为DAD）用于确保网络中不出现两个相同的单播地址。任何地址均需做DAD，使用NS完成DAD。
源地址： unspecified地址
目的地址：请求节点组播地址
若发现有地址重复
随机生成地址：不安排给接口
链路本地地址 ：将接口置于不可用状态

发送方：
地址在配置给接口前称为“试探性地址”
a.加入到all-nodes组播地址和solicited-node组播地址（tentative地址所在的组播）
b.周期性的发出Neighbor Solicitation报文
源地址： unspecified地址
目的地址：请求节点组播地址
Target address： tentative地址
c.若是第一次发出Neighbor Solicitation报文，则主机需要一个随机的延迟
作用：避免所有主机同时发Neighbor Solicitation报文

接收方：
主机收到NS报文后的处理过程：
a.若报文源地址是单播地址，则认为是ARP用；
b.若报文源地址是unspecified地址，且Target address中包含tentative地址，则认为是DAD报文；
若此报文是自己发出的，则忽略此报文；
若报文是其它节点发出的，进行DAD检查，若tentative地址与自己地址重复，则双方都不使用此地址。
c.安全性
用IP认证头（AH）来防止“拒绝服务攻击”

7.邻居可达性检测

8.路由和前缀发现


http://www.ietf.org/rfc/rfc2461
http://www.ietf.org/rfc/rfc3513
http://www.ietf.org/rfc/rfc4861
http://docs.oracle.com/cd/E24847_01/html/819-7058/chapter1-40.html#scrolltoc


???邻居请求／公告，使用的是本地链路地址，还是IP地址？

http://www.h3c.com.cn/Solution/Base_Network_Secrity/IPv6_Solutions/What_Do_I_Need/Bookmark/200711/319403_30004_0.htm

IPV6路径MTU发现
===============
在IPv6中为了简化报文处理流程、提高处理效率，限定IPv6路由器不处理分片，分片只在源节点在需要的时候进行。因此IPv6的路径MTU发现协议是必须实现的。IPv6使用路径MTU发现得到源和目的节点之间路径的最大MTU。源节点在发送报文前进行路径MTU发现处理。如果路径上的MTU不足以传输整个报文，则源节点分片后重新发送。
路径MTU发现协议使IPv6节点能够动态发现并调整以适合给定数据路径上的MTU变化。在IPv4中最小链路MTU值是68字节（推荐最小值为576字节），而在IPv6中最小MTU值为1280字节（推荐最小值为1500）。IPv6基本头支持的最大报文长度是64,000字节。更大的报文（jumbo grams）通过逐跳扩展头选项处理。
http://www.h3c.com.cn/Solution/Base_Network_Secrity/IPv6_Solutions/What_Do_I_Need/Bookmark/200711/319403_30004_0.htm


IPV6域名解析
===============
原有的IPv4 DNS由于应用假定地址查询只返回32比特的IPv4地址，因此不能直接支持IPv6，必须做部分扩展。IPv6引入了新的DNS记录类型用于IPv6地址解析，同时支持正向解析（域名->地址）和反向解析（地址->域名）。
1.统一的域名空间
IPv6网络中的DNS与IPv4的DNS在体系结构上是一致的，都是采用树型结构的域名空间。虽然IPv4协议与IPv6协议是存在着相当大区别的 两套协议，但这并不意味着需要单独两套DNS体系，相反在DNS的体系和域名空间上两者必须是一致的，IPv4和IPv6共同拥有统一的域名空间。在 IPv4到IPv6的过渡阶段，域名可以同时对应于多个IPv4和IPv6的地址。随着IPv6网络的普及，IPv6地址将逐渐取代IPv4地址。

2.IPv6地址的正向解析
IPv4的地址正向解析的资源记录是“A”，而IPv6地址的正向解析目前有两种资源记录，即“AAAA”和“A6”记录。
AAAA纪录
它是较早提出的，是对IPv4协议A记录的简单扩展，表示域名和IPv6地址的对应关系，并不支持地址的层次性。
例如：host1.microsoft.com IN AAAA FEC0::2AA:FF:FE3F:2A1C

A6纪录
它是在RFC2874基础上提出，把一个IPv6地址与多个“A6”记录建立联系，每个“A6”记录都只包含了IPv6地址的一部分，结合后拼装成一个完整的IPv6地址。“A6”记录支持一些“AAAA”所不具备的新特性，如地址聚集，地址更改（Renumber）等。它符合IPv6地址的层次结构，支持地址聚合，修改简单，但由于涉及到与多个DNS服务器的交互，也延长了解析时间,出错的机会也增加。

3.IPv6地址的反向解析
IPv6反向解析的记录和IPv4一样，是“PTR”，但地址表示形式有两种，分别与"AAAA"记录和"A6"记录对应。
地址表示形式的PTR纪录
用 “.”分隔的半字节16进制数字格式，低位地址在前,高位地址在后,域后缀是"IP6.INT."，与"AAAA"对应。
例如，地址FEC0::2AA:FF:FE3F:2A1C（完全表达式为：FEC0:0000:0000:0000:02AA:00FF:FE3F:2A1C）查找域名时，在IP6.INT域中是：C.1.A.2.F.3.E.F.F.F.0.0.A.A.2.0.0.0.0.0.0.0.0.0.0.0.0.0.0.C.E.F.IP6.INT.

二进制串格式的PTR纪录
以"\["开头,16进制地址(无分隔符,高位在前,低位在后) 居中,地址后加"]",域后缀是"IP6.ARPA."，与“A6”记录对应，支持地址层次特性，每一级的授权用“DNAME”记录。

4.DNS服务器的自动发现
DNS服务器自动发现的解决方法可以分为“无状态”和“有状态”两类。
　　在无状态的方式下，需要为子网内部的DNS服务器配置站点范围内的任播地址。要进行自动配置的节点以该任播地址为目的地址发送服务器发现请求，询问 DNS服务器地址、域名和搜索路径等DNS信息。这个请求到达距离最近的DNS服务器，服务器根据请求，回答DNS服务器单播地址、域名和搜索路径等 DNS信息。节点根据服务器的应答配置本机DNS信息，以后的DNS请求就直接用单播地址发送给DNS服务器。
　　另外，也可以不用站点范围内的任播地址，而采用站点范围内的多播地址或链路多播地址等。还可以一直用站点范围内的任播地址作为DNS服务器的地址，所有的DNS解析请求都发送给这个任播地址。距离最近的DNS服务器负责解析这个请求，得到解析结果后把结果返回请求节点，而不像上述做法是把DNS服务器 单播地址、域名和搜索路径等DNS信息告诉节点。从网络扩展性，安全性，实用性等多方面综合考虑，第一种采用站点范围内的任播地址作为DNS服务器地址的 方式相对较好。
    在有状态的DNS服务器发现方式下，是通过类似DHCP这样的服务器把DNS服务器地址、域名和搜索路径等DNS信息告诉节点。当然，这样做需要额外的服务器。


http://www.h3c.com.cn/Solution/Base_Network_Secrity/IPv6_Solutions/What_Do_I_Need/Bookmark/200711/319403_30004_0.htm
http://www.360doc.com/content/12/0313/13/3725126_193980948.shtml

IPV6向IPV4过渡采用的技术
=====================================
过渡时的问题：
1.每个孤立的ipv6网络间如何（通过现有ipv4网络）达到互通目的。
2.ipv6网络和现有ipv4网络如何能相互通信。
针对以上两类问题，有三种技术：双协议栈（RFC 2893 obsolete RFC1933）、隧道技术(RFC 2893，也称隔离技术)、NAT-PT(RFC 2766，协议转换技术)。隧道技术和双栈技术是第一个问题的解决方案，地址头翻译技术（或协议转换技术）是第二个问题的解决方案。

    隧道技术往往运用在IPv6网被运行的IPv4主干网隔离的情况，IPv6网象是处于IPv4海洋中的IPv6孤岛，隧道技术就是使IPv6孤岛相互通信。假设主机PC-A位于IPv6网络中，希望与另一IPv6网络中PC-B主机发送数据，路由器R1（与PC-A相连）和路由器R2（与PC-B相连）之间的网络是纯IPv4网络，隧道技术的工作原理实现过程简述如下： 
  首先，主机PC-A将IPv6数据包发送到路由器R1上。然后路由器R1接收到数据包后，把该数据包封装在一个IPv4首部中，发送到路由器R2。最后路由器R2收到数据包后，解开数据包的封装，剥离IPv4首部，取出IPv6数据包，转发至最终目的地主机PC-B。

配置隧道
IPV6 GRE隧道
配置隧道适应于点到点的通信，两点间的配置项需要相对应,IPV4Header+TunnelHeader+IPV6Header+IPV6Data

手工配置隧道（Configured Tunnel）
IPV4Header+IPV6Header+IPV6Data
适用于经常通信的IPv6地址。
不需要为站点分配特殊的IPv6地址（并不内嵌IPv4地址），目的IPv4地址通过手工配置，需要边缘路由器拥有一个公网IPv4地址，且双栈。

自动配置隧道（Auto-configuration Tunnel）
它的建立和撤除是动态的，不需要事先配置。自动配置的隧道必须满足站点采用IPv4兼容的IPv6地址（0::IPv4ADDR/96），并且提供一个可用的IPv4地址，该隧道技术要求两个端点必须支持双协议栈。

6to4隧道（6to4 Tunnel）
6to4隧道技术可以实现适用于多个6to4域之间的通信，它不经过事先声明的IPv4隧道，是灵活的动态隧道，只需较少的人工配置即可使IPv6节点之间通过IPv4网络进行通信。
IPv6报文采用2002::IPv4-address::/48的地址空间，IPv6地址自动从站点的IPv4地址派生出来的。该地址也容易使得其他域的边界路由器自动区分隧道接收端点是否在本站内，不会在IPv4的路由表中引入新的条目（如IPv4地址：132.214.1.10则Ipv6地址：2002:84d6:010a::EUI-64）。它需要边缘路由器拥有一个公网IPv4地址，并使用RA将此前缀进行公告，使主机拥有一个6to4地址，2002::IPv4-address::/48前缀的IPv6路由不需要在6to4站点之间进行传播。

*6over4隧道（IPv6 over IPv4）
它是一种IPv4组播隧道机制，这种机制适用于与IPv6路由器没有直接连接的物理链路上孤立的IPv6主机，可以将IPv4组播域作为它们的虚拟链路，通过IPv6组播地址和IPv4组播地址的映射关系实现IPv6协议的邻居发现功能，实现完全的IPv6功能。


ISATAP（Intra-Site Automatic Tunnel Addressing Protocol）
站内自动隧道寻址协议，用来为没有IPv6路由器的IPv4内部网中的IPv6节点提供IPv6连接。
ISATAP地址内嵌IPv4地址，IPv6地址前缀为正常Ipv6地址，EUI-64字段改为存储IPv4地址（::0:5EFE:ipv4 address），（如：IPv4地址： 132.214.1.10则IPv6地址：3ffe::0:5EFE:84d6:010a/64，IPv4地址可以为私网IP）。
对于同一逻辑子网（IPv4地址）内部的通信，直接从IPv6地址中获取IPv4地址；如果需要跨逻辑子网进行通信，需要使用ISATAP路由器，主机和路由器之间可以跨Ipv4网络；在主机上，首先手工配置ISATAP的IPv4地址，然后向ISATAP路由器发送RS，并接收RA进行自动地址配置，最后主机将默认路由指向ISATAP路由器。


隧道技术不能实现IPv4主机和IPv6主机之间的通信。
地址与协议转换地址与协议转换（翻译）技术在文档RFC2765和RFC2766中定义和描述，既是将IPv4（IPv6）分组转换成IPv6(IPv4)分组，意思就是将发往IPv6节点的IPv4报头转换成IPv6报头，或者将发往IPv4的IPv6报头转换成IPv4报头，实现IPv4/IPv6网络间的互联。地址与协议转换技术所对应计算机网络体系结构的层次，分为网络层转换，传输层转换和应用层转换三类，网络层转换目前是常用的一种方式。
  （1）无状态IP/ICMP转换（SIIT，Stateless IP/ICMP Translation）
文档RFC2765对SIIT进行了定义与描述，本质是在IPv4与IPv6的分组首部之间进行翻译转换，它不记录流的状态，所以称之为无状态的。较多用于纯IPv6站点和纯IPv4站点间的通行，该机制常与其他机制相结合。 
  （2）网络地址转换与协议转换（NAT-PT）
  NAT-PT技术是最常用的协议转换技术，在RFC2766文档中有描述和定义。NAT-PT的基本原理是利用IPv4地址池指定的IPv4地址给IPv6，作为IPv6节点与IPv4网络通信时暂时对应的IP地址。其实就是建立IPv6与IPv4地址之间的映射表，在NAT-TP技术中，定义了转换地址，即前缀是::FFFF:F0/96，后32位为IPv4地址形式的IPv6地址。所以，在NAT-TP技术中一般认为IPv6地址就是0:FFFF:0/96。就用不着在IPv4中专门维护IPv6地址池，减轻了网络管理的负担。 
  （3）应用层网关技术（ALG）
应用层网关(ALG)是在应用层对数据进行处理，技术有DNS-ALG、SOCKS64网关、Apl碰撞等。


配置
双栈技术
配置起来相对简单，在路由器上对同一个接口配置一个IPv4地址同时配置一个IPv6地址，在路由器上同时运行IPv4和IPv6两种路由协议，这样两种网络可以互通。

隧道配置
不对的配置：
ip tunnel add sit1 remote 202.120.2.47 local 192.168.0.205
ip link set sit1 up
ifconfig sit1 add 2001:da8:8000:d010:0:5efe:192.168.0.104/64
ip -6 route add ::/0 via 2001:da8:8000:d010::1 metric 1 dev sit1

ip link set sit1 down
ip tunnel del sit1
不能用sit0

http://hi.baidu.com/sdshigang/item/ab1be00d163d10e9349902c8
http://www.ibm.com/developerworks/cn/linux/l-cn-ipv6/

测试：
http://ipv6test.google.com/
http://ipv6.google.com

地址-协议转换
SIIT
NAT-PT
ALG
地址协议转换的原理：
NAT-PT是附带协议转换的网络地址转换器，通过修改协议报头来转换网络地址，使IPv4节点和IPv6节点互通。与一些隧道技术不同，NAT-PT只要求在IPv4和IPv6之间互联的网络转换设备上启用，协议转换的目的是实现IPv4和IPv6协议头之间的转换，地址转换则是为了让IPv4和IPv6网络中的主机互相识别对方。另外，NAT-PT通过与应用层网关（ALG）相结合，实现了只安装IPv6的主机和只安装了IPv4主机的大部分应用的相互通信。

实现协议转换，需要以下3部分:
a)NAT(networkaddresstranslation,地址转换部分):负责IPv4和IPv6地址的映射转换。例如存储IPv4地址池、为将要建立的连接选择合适的地址、保持同一会话期间IPv4到IPv6地址的映射、维持已有映射的地址链表、根据会话连接情况动态更新地址链 表、删除或添加地址映射等。
b)PT(protocoltranslation,协议转换部分):负责在两种协议之间进行转换。主要工作是在IP包头的对应字段根据IPv4和IPv6在语义上的不同定义进行转换,从而构建新的数据包。
c)ALG(applicationlevelgateway,应用层网关):NAT-PT本身不转换数据包的负载部分,因此NAT-PT对负载中携带了IP地址的应用无能为力。ALG就是为了解决这种情况而采用的一种代理机制,该代理允许这种应用在IPv6节点和IPv4节点通信,对负载中包含IP地址的典型应用进行转换,所以不同应用的ALG和NAT-PT联合使用可提供对多种应用层的支持。DNS-ALG是实现双向转换所必备的,FTP-ALG和SIP-ALG是典型的为完成相应功能的应用层网关。

过程描述：
ipv4->ipv6
步骤如下:
a)IPv4主机向IPv4DNS服务器发出解析请求,如果不能本地解析,则转至NAT-PT;
b)该请求被NAT-PT服务器获取;
c)DNS-ALG将请求进行修改,然后发给IPv6侧的IPv6DNS服务器;
d)IPv6DNS服务器应答目的主机的IPv6地址;
e)NAT-PT服务器将该IPv6地址与自身维护的IPv4地址池中的一个IPv4地址建立映射关系,并在地址映射表中记录这一映射关系,地址映射部分将与原IPv6地址对应的IPv4地址返回DNS󰀁ALG;例如:211.66.59.10对应2001::1;
f)DNS-ALG将此IPv4地址应答给发出请求的IPv4主机;
g)IPv4主机以此IP地址(211.66.59.10)为目的地址进行通信;
h)NAT-PT服务器截获使用伪目的地址的IP分组,并在地址映射表中查找真正的目的地址,地址映射表返回目的主机的IPv6地址;协议转换部分对IP分组进行头标替换,将源地址修改为IPv4映射地址,目的地址改为目的主机的IPv6地址,并发送。
IPv6主机访问IPv4时,NAT-PT服务器工作过程基本不变,只是在步骤d略有不同。IPv4侧的DNS服务器应答了目的主机的IPv4地址,DNS-ALG接到IPv4address信息,向NAT-PT要prefix,把它加上变成IPv6地址(prefix:211.65.59.55);NAT-PT服务器应答发起会话的IPv6主机,但此时并不建立IPv4/IPv6地址映射,地址映射关系是在会话的首个包到达NAT-PT服务器时建立。


原理的实现：netfilter

所需：
一个可以完成协议转换的第三方软件
需要内核和文件系统中支持iptables和ip6tables
需要一个ipv6的dns服务

在PC上对协议转换机制的实现过程：
服务器：Linux的Ubuntu 12.04发行版系统。支持ipv6+ipv4栈和ipv4双栈，安装naptd协议转换(ipv6<->ipv4转换)工具。单网卡，ipv4地址：192.168.28.170，ipv6地址：fc00::170/64。
客户端：ipv6的Windows系统，ipv6地址：为fc00::168/64。
大体流程：
a.客户端：向开发板发送ipv6数据包，
b.开发板：收到ipv6包后在其内部将数据包通过协议转换机制转换成ipv4数据包，转换后的ipv4数据包送到上层只支持ipv4的应用。
c.开发板：上层ipv4应用发出ipv4响应包，ipv4包被协议转换机制转换成ipv6数据包，转换后的ipv6响应包发送出去。
d.客户端：收到开发板转换后的ipv6响应包。

服务器配置过程：
1.ip地址配置
#ip -6 addr add fc00::170/64 dev eth0
#ifconfig eth0
eth0      Link encap:以太网  硬件地址 f0:de:f1:f0:08:60  
          inet 地址:192.168.28.170  广播:192.168.28.255  掩码:255.255.255.0
          inet6 地址: fe80::f2de:f1ff:fef0:860/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  跃点数:1
          接收数据包:16236 错误:0 丢弃:0 过载:0 帧数:0
          发送数据包:6112 错误:0 丢弃:0 过载:0 载波:0
          碰撞:0 发送队列长度:1000 
          接收字节:4338464 (4.3 MB)  发送字节:1133955 (1.1 MB)
          中断:41 基本地址:0x6000 
这里，主要配置好网卡的ipv6地址，因为没有公有ipv6地址，所以这里配置的是本地唯一地址（ipv6的私有地址）。

2.防火墙设置
#sysctl -w net.ipv6.conf.all.forwarding=1
#ip6tables -A OUTPUT -p icmpv6 --icmpv6-type 1 -j DROP
#ip6tables -A FORWARD -d 2000:ffff:: -j DROP
#echo 1 >/proc/sys/net/ipv4/ip_forward
#iptables -A INPUT -i lo -j ACCEPT
#iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
#iptables -A INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT
#iptables -A INPUT -j DROP
这里，首先开启ipv6和ipv4的转发功能。然后分别使用ip6tables和iptables向内核防火墙中添加相应的过滤规则。规则的具体含义，需要先了解iptables和ip6tables的使用方法，以及参考naptd的官方文档。
root@quietheart-ThinkPad-E420:/home/quietheart/work# iptables -L
Chain INPUT (policy ACCEPT)
target     prot opt source               destination         
ACCEPT     all  --  anywhere             anywhere            
ACCEPT     all  --  anywhere             anywhere             state RELATED,ESTABLISHED
ACCEPT     tcp  --  anywhere             anywhere             state NEW tcp dpt:ssh
DROP       all  --  anywhere             anywhere            

Chain FORWARD (policy ACCEPT)
target     prot opt source               destination         

Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination         
root@quietheart-ThinkPad-E420:/home/quietheart/work# ip6tables -L
Chain INPUT (policy ACCEPT)
target     prot opt source               destination         

Chain FORWARD (policy ACCEPT)
target     prot opt source               destination         
DROP       all      anywhere             2000:ffff::/128     

Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination         
DROP       ipv6-icmp    anywhere             anywhere             ipv6-icmp destination-unreachable



3.naptd配置和启动
编译好naptd程序后，使用下面方法配置：
下面使用交互式程序naptd-confmaker进行配置，对每一个交互问题会有相应解释。
# naptd-confmaker
Do you want to create a new configuration? [Y/n]
(这里询问是否需要对naptd进行重新配置，直接回车表示选Y。)
Do you want IPv4 addresses from the outside interfaces to be automatically used as part of the NAT pool? [Y/n]
n
（这里询问是否直接使用ipv4的网口IPV4地址作为对IPV6地址池的一员来映射，这里选n，具体含义见后。）
You need to create a public IPv4 address pool. Enter the pool's starting IP.
starting IP: 192.168.28.170
ending IP (inclusive) [192.168.28.170]: 

Enter the port range to use for this address pool.
starting port [1050]: 0
ending port (inclusive) [65000]: 

Do you want to enter more address pools? [y/N]
（这里，因为选了n，也就是不直接使用ipv4网卡的地址作为地址池的一员，所以需要手动创建IPV4地址池，分别输入其起始地址，结束地址，以及需要支持的端口，如果直接回车就是使用'[]'里面列出的地址，最后询问是否还要另建地址池，这里回车表示N，不用。对于地址池的解释，需参考NAT-PT协议和naptd的官网，大致含义是：ipv6主机和ipv4进行交互时，ipv6会从地址池中选择一个ipv4地址来和ipv4进行交互，naptd会将ipv6地址转换成这个选中的ipv4地址，然后在把ipv6包转换成ipv4包，和目标ipv4主机交互，ipv4主机不知道和他交互的是ipv6主机，将使用ipv6主机从地址池中选择的ipv4映射地址和ipv6主机交互，naptd会将ipv4主机的ipv4包转换成ipv6包，并且根据其ipv4目标地址与地址池的地址比较，将目标地址改成相应的ipv6地址，并将数据包回应到正确的ipv6主机上）。

Do you want to create a pool of public IPv4 addresses that will allow incoming connections to be dynamically mapped to appropriate IPv6 addresses? [y/N]
（这里，首先询问是否动态创建访问进来的地址映射，因为这需要借助ipv6的dns，所以直接回车表示选N，地址映射见后解释）。
Do you want to create static mappings of public IPv4 addresses that will allow incoming connections to reach IPv6 hosts? [y/N]
y
IPv4 address: 192.168.28.170
IPv6 address: fc00::170

Do you want to enter another static mapping? [y/N]
（这里，询问是否静态创建访问进来的地址映射，选y表示创建，然后分别输入相互映射的ipv4地址和ipv6地址，最后又询问是否静态创建更多的映射，这里我们只要一个，所以直接回车表示不创建。这里地址映射的意思需要参考NAT-PT协议以及naptd官方文档，大致意思是：当外部ipv4主机要主动和ipv6主机发起通信时，ipv4主机直接向地址映射中的ipv4地址发送ipv4信息，natptd程序会将ipv4包转换成ipv6包，并向ipv4包的目的ipv4地址对应的在地址映射中的ipv6主机发送转换后的ipv6包）。


Enter the name of the first inside (IPv6) interface that you want NAT-PT to listen on.
interface (eth0 wlan0): eth0

Do you want to enter more interfaces? [y/N]

Enter the name of the first outside (IPv4) interface that you want NAT-PT to listen on.
interface (eth0 wlan0): eth0

Do you want to enter more interfaces? [y/N]
（这里，询问naptd监听的内部接口和外部接口，因为我们只有一个eth0网口，所以全选eth0，并且不监听其它。对于监听的接口，是指：naptd会监听内部网口和外部接口上收发的ipv4和ipv6数据包，并且对其进行必要的ipv4<->ipv6转换，因为我们一般是内部的纯ipv6主机向外访问已有的ipv4资源，所以内部网口是ipv6的网口，外部网口是ipv4的网口）

Enter the TCP translation timeout in seconds [86400]: 
Enter the UDP translation timeout in seconds [3600]: 
Enter the ICMP translation timeout in seconds [30]: 

Enter the IPv6 prefix that will be used as the destination for translations.
prefix [2000:ffff::]: 

Please enter the IPv4 address of the DNS server you are currently using.
IPv4 DNS server: 202.96.134.33

You can configure hosts for automatic DNS translation by using the DNS server below.
IPv6 DNS Server: 2000:ffff::ca60:8621

Thank you for choosing Ataga as you IPv4/IPv6 NAT-PT solution.
Setup is now complete. Type 'naptd' to start NAT-PT.


# naptd
Going daemon. Check syslog messages for runtime information.



4.路由表
#ip -6 route add 2000:ffff::/64 src fc00::170 dev eth0
# ip -6 route list
2000:ffff::/64 dev eth0  src fc00::170  metric 1024 
fc00::/64 dev eth0  proto kernel  metric 256 
fe80::/64 dev eth0  proto kernel  metric 256 


*http://tomicki.net/ipv6.router.php
http://blog.csdn.net/mounter625/article/details/5429824
http://blog.chinaunix.net/uid-26824563-id-3192638.html
*http://www.51cto.com/art/200708/52786.htm
*http://wenku.baidu.com/link?url=UxgbjdqmMtpoNwHcJPXQzZXhKJNAGAmZyYmWQDUw79PtJvMbjgSEp0O2bMxVf8YuRjgHPGUfMW-OHKggVqdrJNZ3X76AB735cRHvtnAelvS
http://tech.ccidnet.com/art/1084/20071111/1271585_1.html


http://wenku.baidu.com/link?url=PwFpNGL-MRZCSzEgLCkVeHXVxTOZH9GiqNHbF8BehelL_oQiJeo9-hQJSSKmbb3RftO6OjHI_C8jTQttFf5clUrzh6gQSQhbghfH-5NLpmu
http://wenku.baidu.com/view/f7e74200b52acfc789ebc924.html
http://wenku.baidu.com/link?url=iJo0zcB69KcDiXLLcW4eNwyPstyyiaYp-EkF_i6Uq6aalCyFt1SzkVEkD5SoYMFhVqsIN1Hv9gd8VLZbJu8yIBiLikx2RgBFKf-65B5jXk_###
http://wenku.baidu.com/view/7c2911abd1f34693daef3ecd.html

5.客户端访问
http://[fc00::170]:80
或http://[fc00::170]
需要注意的是要用'[]'将ipv6括起来进行访问。如果需要端口的话，端口号放在后面。有些浏览器如chrome不用加"http://"前缀。


六、自动配置ipv6地址




dhcpv6服务器搭建（待实践）
============
# apt-get install dibbler-server
# vim /etc/dibbler/server.conf

客户端：
#apt-get install dibbler-client

http://xiaopangxiongyuan.blog.163.com/blog/static/12490117020119935320844/

windows下的配置
nic.seu.edu.cn/s/8/t/316/d8/2d/info55341.htm
klub.com.pl/dhcpv6/#DOWNLOAD



windows和linux互相ping通：
==============
1.windows 7
(1)从菜单下手配置IPv6参数:
开始->右击"网络"->属性->本地连接->属性->双击internet协议版本6(tcp/IPv6)
在弹出的配置页面，设置如下：
IPv6地址：fc00::158
子网前缀长度：64
默认网关：fc00::1

2.Ubuntu 12.04
# ip -6 addr add fc00::163/64 dev eth0

3.测试：
windows下
ping -6

Ubuntu下
ping6

对本地链路地址和设置的地址，均可互相连通。


   地址类型              二进制前缀            ipv6表示
   ------------         -------------        -------------
   Unspecified          00...0  (128 bits)   ::/128       
   Loopback             00...1  (128 bits)   ::1/128      
   Multicast            11111111             FF00::/8     
   Link-local unicast   1111111010           FE80::/10    
   Site-local unicast   1111111011           FEC0::/10    
   Global unicast       (everything else)

   Anycast addresses are taken from the unicast address spaces (of any
   scope) and are not syntactically distinguishable from unicast
   addresses.


本地链路地址：link-local address
当在一个节点启用IPV6，启动时节点的每个接口自动生成一个link-local address
其前缀64位为标准指定的，其后64位按EUI-64格式来构造
注意：在本链路上，路由表中看到的下一跳都是对端的Link Local地址,不是公网IP地址
前缀：FE80::/10
范围：只能在本地链路使用，不能在子网间路由
为何需要link-local--在一个接口可以配置很多IPv6地址，所以学习路由就有可能出现很多下一跳。
所以出现Link Local地址唯一标识一个节点。在本地链路看到下一跳都是对端的Link Local地址。
在网络重新编址过程中，节点和路由器的Link Local地址不会发生变化，可以很容易地做一个修改，不用担心网络不可达。

链路本地地址使用场合：1，路由器使用链路本地地址作为它们发送的RA消息的默认网关2，运行路由协议的路由器利用链路本地地址来建立邻接关系。3，IPv6路由表中的动态路由使用链路本地地址作为下一跳地址。

3、本地站点地址：site-local address
IPV6的私网地址，就像IPV4中的私网保留地址一样
只占用到整个IPV6地址空间的0.1%
前缀：FEC0::/10 其后的54比特用于子网ID 最后64位用于主机ID
范围：只能在本站点内使用，不能在公网上使用
例如：在本地分配十个子网
1、FEC0:0:0:0001::/64
2、FEC0:0:0:0002::/64
3、FEC0:0:0:0003::/64
10、FEC0:0:0:000A::/64
本地站点地址被设计用于永远不会与全球IPV6因特网进行通信的设备，比如：打印机、内部网服务器、网络交换机等

唯一本地地址：取代之前的 站点本地地址的叫法，具体用途：在百度知道有人回复：打个比方你就明白了：现在有个企业内网全网ipv6，分财务部和市场 部，很显然财务部和市场部是两个不同的子网，财务部和市场部之间交流用本地唯一地址，这个特点体现了它的组织内部特点，因为它们都属于企业内部。财务部和财务部或者市场部和市场部之间交流用链路本地地址，这个体现了他的本地子网特点。你先把ipv4分类特点抛开，再来看，不然很容易混淆。


http://blog.163.com/hlz_2599/blog/static/14237847420125710051589/
http://www.enet.com.cn/article/2013/0731/A20130731299435_2.shtml



使telnet支持ipv6
#vim /etc/xinetd.d/telnet
将"flags=REUSE" 改成"flags=REUSE IPv6"

#service xinetd restart

#telnet fc00::f2de:f1ff:fef0:861
注意，不能用本地链路地址登录，实践发现，这样之后也能用ipv4地址登入。
